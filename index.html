<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¯æ—¥å•è¯è®°å½•æœ¬</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS (xlsx) CDN for Excel Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
        }
        /* è‡ªå®šä¹‰åŠ¨ç”» */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        /* å·²æŒæ¡å•è¯çš„æ ·å¼ */
        .mastered {
            text-decoration: line-through;
            opacity: 0.6;
        }
        /* é¼“åŠ±æç¤ºçš„æ ·å¼ */
        #encouragement-toast {
            transform: translateX(-50%) translateY(-100px);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        #encouragement-toast.show {
            transform: translateX(-50%) translateY(20px);
            opacity: 1;
        }
        /* å¯¼å‡ºæ¨¡æ€æ¡†èƒŒæ™¯ */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-backdrop.show {
            opacity: 1;
            visibility: visible;
        }
        /* å¯¼å‡ºæ¨¡æ€æ¡†å†…å®¹ */
        .modal-content {
            transform: scale(0.9);
            transition: transform 0.3s ease-in-out;
        }
        .modal-backdrop.show .modal-content {
            transform: scale(1);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <!-- é¼“åŠ±æç¤ºå®¹å™¨ -->
    <div id="encouragement-toast" class="fixed top-4 left-1/2 z-50 bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
        <span id="encouragement-text"></span>
    </div>

    <!-- å¯¼å‡ºæ¨¡æ€æ¡† -->
    <div id="export-modal" class="modal-backdrop fixed inset-0 z-40 flex items-center justify-center p-4">
        <div class="modal-content bg-white rounded-lg shadow-xl p-6 w-full max-w-md max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">é€‰æ‹©å¯¼å‡ºæ—¥æœŸ</h3>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-700 text-2xl leading-none">&times;</button>
            </div>
            <div id="export-options" class="space-y-2">
                <!-- é€‰é¡¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-4xl">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">ğŸ“š æ¯æ—¥å•è¯è®°å½•æœ¬</h1>
            <p class="text-gray-600">è®°å½•ä½ çš„æ¯ä¸€ç‚¹è¿›æ­¥</p>
        </header>

        <!-- Main Content -->
        <main>
            <!-- Add Word Form -->
            <section class="bg-white rounded-lg shadow-md p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">æ·»åŠ æ–°å•è¯</h2>
                <form id="word-form" class="space-y-4">
                    <div>
                        <label for="word-input" class="block text-sm font-medium text-gray-700">å•è¯</label>
                        <input type="text" id="word-input" required
                               class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                               placeholder="e.g., serendipity">
                    </div>
                    <div>
                        <label for="meaning-input" class="block text-sm font-medium text-gray-700">é‡Šä¹‰</label>
                        <textarea id="meaning-input" rows="2"
                                  class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                                  placeholder="e.g., æ„å¤–å‘ç°çå¥‡äº‹ç‰©çš„è¿æ°”ï¼›æœºç¼˜å·§åˆ"></textarea>
                    </div>
                    <div>
                        <label for="synonym-input" class="block text-sm font-medium text-gray-700">åŒä¹‰è¯</label>
                        <textarea id="synonym-input" rows="2"
                                  class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                                  placeholder="e.g., fortune, luck, fluke"></textarea>
                    </div>
                    <div>
                        <label for="phrase-input" class="block text-sm font-medium text-gray-700">è¯ç»„</label>
                        <textarea id="phrase-input" rows="2"
                                  class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                                  placeholder="e.g., a stroke of serendipity"></textarea>
                    </div>
                    <button type="submit"
                            class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">
                        æ·»åŠ å•è¯
                    </button>
                </form>
            </section>

            <!-- Export and Stats Section -->
            <section class="mb-8">
                <div class="mb-4">
                    <button id="export-trigger-btn"
                            class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition duration-300 flex items-center justify-center">
                        ğŸ“Š å¯¼å‡ºä¸ºExcel
                    </button>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="bg-white p-4 rounded-lg shadow text-center">
                        <p class="text-gray-500 text-sm">æ€»è¯æ±‡é‡</p>
                        <p id="total-words" class="text-2xl font-bold text-indigo-600">0</p>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow text-center">
                        <p class="text-gray-500 text-sm">å­¦ä¹ å¤©æ•°</p>
                        <p id="study-days" class="text-2xl font-bold text-green-600">0</p>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow text-center">
                        <p class="text-gray-500 text-sm">ä»Šæ—¥æ–°è¯</p>
                        <p id="today-words" class="text-2xl font-bold text-blue-600">0</p>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow text-center">
                        <p class="text-gray-500 text-sm">å·²æŒæ¡</p>
                        <p id="mastered-words" class="text-2xl font-bold text-purple-600">0</p>
                    </div>
                </div>
            </section>

            <!-- Word List -->
            <section id="word-list-container" class="space-y-6">
                <!-- Words will be dynamically inserted here -->
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const STORAGE_KEY = 'dailyWords';
            const wordForm = document.getElementById('word-form');
            const wordInput = document.getElementById('word-input');
            const meaningInput = document.getElementById('meaning-input');
            const synonymInput = document.getElementById('synonym-input');
            const phraseInput = document.getElementById('phrase-input');
            const wordListContainer = document.getElementById('word-list-container');
            const exportTriggerBtn = document.getElementById('export-trigger-btn');
            const exportModal = document.getElementById('export-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const exportOptions = document.getElementById('export-options');
            const encouragementToast = document.getElementById('encouragement-toast');
            const encouragementText = document.getElementById('encouragement-text');

            // --- é¼“åŠ±è¯­å¥åº“ ---
            const encouragements = [
                "å¤ªæ£’äº†ï¼åˆæŒæ¡ä¸€ä¸ªæ–°å•è¯ï¼",
                "åšæŒå°±æ˜¯èƒœåˆ©ï¼",
                "ä½ çš„è¯æ±‡é‡æ­£åœ¨ç¨³æ­¥å¢é•¿ï¼",
                "Excellent! Keep it up!",
                "çŸ¥è¯†å°±æ˜¯åŠ›é‡ï¼Œä½ æ­£åœ¨å˜å¼ºï¼",
                "ä»Šå¤©çš„ä½ æ¯”æ˜¨å¤©æ›´åšå­¦äº†ï¼",
                "Amazing! æ¯ä¸€ä¸ªå•è¯éƒ½æ˜¯ä¸€å—åŸºçŸ³ã€‚",
                "æŒä¹‹ä»¥æ’ï¼Œç»ˆå°†å¤§æˆï¼",
                "ä½ çš„åŠªåŠ›ï¼Œæ—¶é—´çœ‹å¾—è§ï¼",
                "åˆå‘ç›®æ ‡è¿ˆè¿›äº†ä¸€æ­¥ï¼"
            ];

            // --- Data Management ---
            const loadWords = () => {
                const data = localStorage.getItem(STORAGE_KEY);
                return data ? JSON.parse(data) : {};
            };

            const saveWords = (words) => {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(words));
            };

            // --- Modal Logic ---
            const showExportModal = () => {
                const wordsData = loadWords();
                const dates = Object.keys(wordsData).sort((a, b) => new Date(b) - new Date(a));

                exportOptions.innerHTML = ''; // Clear previous options

                if (dates.length === 0) {
                    exportOptions.innerHTML = '<p class="text-gray-500 text-center">æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®ã€‚</p>';
                } else {
                    // "Export All" button
                    const exportAllBtn = document.createElement('button');
                    exportAllBtn.textContent = 'ğŸ“¦ å¯¼å‡ºå…¨éƒ¨æ•°æ®';
                    exportAllBtn.className = 'w-full text-left p-3 border-2 border-indigo-600 text-indigo-600 rounded-lg hover:bg-indigo-50 font-semibold transition duration-300';
                    exportAllBtn.onclick = exportAllData;
                    exportOptions.appendChild(exportAllBtn);
                    
                    // Individual date buttons
                    dates.forEach(dateStr => {
                        const dayWords = wordsData[dateStr];
                        const dateObj = new Date(dateStr + 'T00:00:00');
                        const formattedDate = dateObj.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });
                        
                        const dateBtn = document.createElement('button');
                        dateBtn.textContent = `${formattedDate} (${dayWords.length} ä¸ªå•è¯)`;
                        dateBtn.className = 'w-full text-left p-3 border border-gray-300 rounded-lg hover:bg-gray-50 transition duration-300';
                        dateBtn.onclick = () => exportDataForDate(dateStr, formattedDate);
                        exportOptions.appendChild(dateBtn);
                    });
                }

                exportModal.classList.add('show');
            };

            const hideExportModal = () => {
                exportModal.classList.remove('show');
            };

            // --- Excel Export Functions ---
            const exportDataForDate = (dateStr, formattedDate) => {
                const wordsData = loadWords();
                const wordsForDate = wordsData[dateStr] || [];
                const allWords = [];

                wordsForDate.forEach(word => {
                    allWords.push({
                        'æ—¥æœŸ': dateStr,
                        'å•è¯': word.word,
                        'é‡Šä¹‰': word.meaning || '',
                        'åŒä¹‰è¯': word.synonym || '',
                        'è¯ç»„': word.phrase || '',
                        'æŒæ¡çŠ¶æ€': word.mastered ? 'å·²æŒæ¡' : 'å­¦ä¹ ä¸­'
                    });
                });

                if (allWords.length === 0) {
                    alert('è¯¥æ—¥æœŸæ²¡æœ‰æ•°æ®å¯ä»¥å¯¼å‡ºï¼');
                    return;
                }

                const ws = XLSX.utils.json_to_sheet(allWords);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "å•è¯è®°å½•");
                
                const fileName = `å•è¯è®°å½•_${dateStr}.xlsx`;
                XLSX.writeFile(wb, fileName);
                hideExportModal();
            };
            
            const exportAllData = () => {
                const wordsData = loadWords();
                const allWords = [];

                for (const date in wordsData) {
                    wordsData[date].forEach(word => {
                        allWords.push({
                            'æ—¥æœŸ': date,
                            'å•è¯': word.word,
                            'é‡Šä¹‰': word.meaning || '',
                            'åŒä¹‰è¯': word.synonym || '',
                            'è¯ç»„': word.phrase || '',
                            'æŒæ¡çŠ¶æ€': word.mastered ? 'å·²æŒæ¡' : 'å­¦ä¹ ä¸­'
                        });
                    });
                }

                if (allWords.length === 0) {
                    alert('æ²¡æœ‰æ•°æ®å¯ä»¥å¯¼å‡ºï¼');
                    return;
                }

                const ws = XLSX.utils.json_to_sheet(allWords);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "å•è¯è®°å½•");

                const today = new Date().toISOString().split('T')[0];
                const fileName = `æˆ‘çš„å•è¯è®°å½•_å…¨éƒ¨_${today}.xlsx`;
                XLSX.writeFile(wb, fileName);
                hideExportModal();
            };

            // --- UI Rendering ---
            const renderWords = () => {
                const wordsData = loadWords();
                wordListContainer.innerHTML = '';

                const sortedDates = Object.keys(wordsData).sort((a, b) => new Date(b) - new Date(a));

                if (sortedDates.length === 0) {
                    wordListContainer.innerHTML = '<p class="text-center text-gray-500 bg-white p-8 rounded-lg shadow">è¿˜æ²¡æœ‰è®°å½•ä»»ä½•å•è¯ï¼Œå¿«æ¥æ·»åŠ ç¬¬ä¸€ä¸ªå§ï¼</p>';
                    updateStats(wordsData);
                    return;
                }

                sortedDates.forEach(dateStr => {
                    const dayWords = wordsData[dateStr];
                    const dateObj = new Date(dateStr + 'T00:00:00');
                    const formattedDate = dateObj.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
                    
                    const daySection = document.createElement('div');
                    daySection.className = 'bg-white rounded-lg shadow-md p-6 fade-in';
                    
                    const dateHeader = document.createElement('h3');
                    dateHeader.className = 'text-xl font-semibold text-gray-700 border-b pb-2 mb-4';
                    dateHeader.textContent = `${formattedDate} (${dayWords.length} ä¸ªå•è¯)`;
                    daySection.appendChild(dateHeader);

                    const wordList = document.createElement('ul');
                    wordList.className = 'space-y-4';

                    dayWords.forEach(word => {
                        const wordItem = document.createElement('li');
                        wordItem.className = `p-4 border rounded-lg hover:shadow-md transition-shadow duration-300 ${word.mastered ? 'bg-gray-50' : 'bg-white'}`;
                        wordItem.dataset.date = dateStr;
                        wordItem.dataset.id = word.id;

                        const wordHeaderDiv = document.createElement('div');
                        wordHeaderDiv.className = 'flex justify-between items-start mb-2';

                        const wordTitle = document.createElement('h4');
                        wordTitle.className = `text-lg font-bold text-indigo-800 ${word.mastered ? 'mastered' : ''}`;
                        wordTitle.textContent = word.word;

                        const actionButtons = document.createElement('div');
                        actionButtons.className = 'flex space-x-2';

                        const masterBtn = document.createElement('button');
                        masterBtn.innerHTML = word.mastered ? 'â†©ï¸' : 'âœ…';
                        masterBtn.className = 'text-xl p-1 hover:scale-110 transition-transform';
                        masterBtn.title = word.mastered ? 'æ ‡è®°ä¸ºæœªæŒæ¡' : 'æ ‡è®°ä¸ºå·²æŒæ¡';
                        masterBtn.onclick = () => toggleMaster(dateStr, word.id);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.innerHTML = 'ğŸ—‘ï¸';
                        deleteBtn.className = 'text-xl p-1 hover:scale-110 transition-transform';
                        deleteBtn.title = 'åˆ é™¤';
                        deleteBtn.onclick = () => deleteWord(dateStr, word.id);

                        actionButtons.appendChild(masterBtn);
                        actionButtons.appendChild(deleteBtn);
                        wordHeaderDiv.appendChild(wordTitle);
                        wordHeaderDiv.appendChild(actionButtons);
                        wordItem.appendChild(wordHeaderDiv);
                        
                        if (word.meaning) {
                            const meaningP = document.createElement('p');
                            meaningP.className = 'text-gray-600 mb-1';
                            meaningP.innerHTML = `<strong>é‡Šä¹‰:</strong> ${word.meaning}`;
                            wordItem.appendChild(meaningP);
                        }

                        if (word.synonym) {
                            const synonymP = document.createElement('p');
                            synonymP.className = 'text-gray-600 mb-1';
                            synonymP.innerHTML = `<strong>åŒä¹‰è¯:</strong> ${word.synonym}`;
                            wordItem.appendChild(synonymP);
                        }

                        if (word.phrase) {
                            const phraseP = document.createElement('p');
                            phraseP.className = 'text-gray-500 italic text-sm';
                            phraseP.innerHTML = `<strong>è¯ç»„:</strong> ${word.phrase}`;
                            wordItem.appendChild(phraseP);
                        }

                        wordList.appendChild(wordItem);
                    });

                    daySection.appendChild(wordList);
                    wordListContainer.appendChild(daySection);
                });

                updateStats(wordsData);
            };
            
            // --- Stats Update ---
            const updateStats = (wordsData) => {
                let totalWords = 0;
                let masteredWords = 0;
                const today = new Date().toISOString().split('T')[0];
                let todayWordsCount = 0;

                const dates = Object.keys(wordsData);
                dates.forEach(date => {
                    const dayWords = wordsData[date];
                    totalWords += dayWords.length;
                    dayWords.forEach(w => { if (w.mastered) masteredWords++; });
                    if (date === today) {
                        todayWordsCount = dayWords.length;
                    }
                });

                document.getElementById('total-words').textContent = totalWords;
                document.getElementById('study-days').textContent = dates.length;
                document.getElementById('today-words').textContent = todayWordsCount;
                document.getElementById('mastered-words').textContent = masteredWords;
            };

            // --- Actions ---
            const addWord = (e) => {
                e.preventDefault();
                const wordText = wordInput.value.trim();
                const meaningText = meaningInput.value.trim();
                const synonymText = synonymInput.value.trim();
                const phraseText = phraseInput.value.trim();

                if (!wordText) return;

                const today = new Date().toISOString().split('T')[0];
                const wordsData = loadWords();

                if (!wordsData[today]) {
                    wordsData[today] = [];
                }

                const newWord = {
                    id: Date.now(),
                    word: wordText,
                    meaning: meaningText,
                    synonym: synonymText,
                    phrase: phraseText,
                    mastered: false
                };

                wordsData[today].push(newWord);
                saveWords(wordsData);

                wordForm.reset();
                wordInput.focus();
                renderWords();

                showRandomEncouragement();
            };

            const deleteWord = (date, id) => {
                const idStr = String(id);
                if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå•è¯å—ï¼Ÿ')) {
                    const wordsData = loadWords();
                    wordsData[date] = wordsData[date].filter(w => String(w.id) !== idStr);
                    if (wordsData[date].length === 0) {
                        delete wordsData[date];
                    }
                    saveWords(wordsData);
                    renderWords();
                }
            };

            const toggleMaster = (dateï¼Œ id) => {
                const idStr = String(id);
                const wordsData = loadWords();
                const word = wordsData[date]ã€‚find(w => String(wã€‚id) === idStr);
                if (word) {
                    word.mastered = !word.mastered;
                    saveWords(wordsData);
                    renderWords();
                }
            };

            // --- é¼“åŠ±æç¤ºåŠŸèƒ½ ---
            const showRandomEncouragement = () => {
                const randomIndex = Math.floor(Math.random() * encouragements.length);
                const message = encouragements[randomIndex];
                encouragementText.textContent = message;
                
                encouragementToast.classList.add('show');

                setTimeout(() => {
                    encouragementToast.classList.remove('show');
                }, 3000);
            };

            // --- Event Listeners ---
            wordForm.addEventListener('submit', addWord);
            exportTriggerBtn.addEventListener('click', showExportModal);
            closeModalBtn.addEventListener('click', hideExportModal);
            // ç‚¹å‡»èƒŒæ™¯å…³é—­æ¨¡æ€æ¡†
            exportModal.addEventListener('click', (e) => {
                if (e.target === exportModal) {
                    hideExportModal();
                }
            });

            // Initial render
            renderWords();
        });
    </script>
</body>
</html>
